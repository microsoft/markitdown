import io
import base64
from typing import Any, BinaryIO, Optional
from bs4 import BeautifulSoup

from .._base_converter import DocumentConverter, DocumentConverterResult
from .._stream_info import StreamInfo
from ._markdownify import _CustomMarkdownify

from ._image_converter import ImageConverter
from bs4 import BeautifulSoup
import re

ACCEPTED_MIME_TYPE_PREFIXES = [
    "text/html",
    "application/xhtml",
]

ACCEPTED_FILE_EXTENSIONS = [
    ".html",
    ".htm",
]


class HtmlConverter(DocumentConverter):
    """Anything with content type text/html"""

    def __init__(self):
        super().__init__()
        self._img_converter = ImageConverter()

    def accepts(
        self,
        file_stream: BinaryIO,
        stream_info: StreamInfo,
        **kwargs: Any,  # Options to pass to the converter
    ) -> bool:
        mimetype = (stream_info.mimetype or "").lower()
        extension = (stream_info.extension or "").lower()

        if extension in ACCEPTED_FILE_EXTENSIONS:
            return True

        for prefix in ACCEPTED_MIME_TYPE_PREFIXES:
            if mimetype.startswith(prefix):
                return True

        return False

    def __replace_embedded_images_with_llm_desc(
        self, soup: BeautifulSoup, **kwargs: Any
    ) -> BeautifulSoup:
        """
        Replaces embedded images in the HTML with a description generated by a multimodal LLM.
        Args:
            html (str): The HTML content containing embedded images.
            kwargs (Any): Additional keyword arguments, including the LLM model, llm_client and llm_prompt.
        Returns:
            str: The modified HTML content with embedded images replaced by descriptions.
        """

        llm_client = kwargs.get("llm_client")
        llm_model = kwargs.get("llm_model")

        if llm_client is None or llm_model is None:
            return soup
        else:
            for img in soup.find_all("img"):
                src = img.get("src", "")

                if src.startswith("data:image/"):
                    try:
                        # Extract MIME type and base64 data
                        data_header, base64_data = src.split(",", 1)
                        mimetype = data_header.split(";")[0].replace("data:", "")

                        # Decode base64 to binary data
                        binary_data = base64.b64decode(base64_data)
                        file_stream = io.BytesIO(binary_data)

                        # Determine file extension from MIME type
                        extension_map = {
                            "image/png": ".png",
                            "image/jpeg": ".jpg",
                            "image/jpg": ".jpg",
                            "image/gif": ".gif",
                            "image/webp": ".webp",
                        }
                        extension = extension_map.get(mimetype, ".png")

                        # Convert image to description using the image converter
                        result = self._img_converter.convert(
                            file_stream,
                            StreamInfo(
                                mimetype=mimetype,
                                extension=extension,
                            ),
                            **kwargs,  # Pass all kwargs including llm_client, llm_model, etc.
                        )

                        # Get the description from the result
                        description = (
                            result.markdown.strip()
                            if result.markdown
                            else "Image description not available"
                        )

                        # Replace the image with the description
                        desc_tag = soup.new_tag(
                            "p", attrs={"style": "border: 1px solid black"}
                        )
                        desc_tag.string = (
                            f"## [embedded image] ##\n ``` {description} ```"
                        )
                        img.replace_with(desc_tag)

                    except Exception as e:
                        # If there's an error processing the image, keep original or add error message
                        error_tag = soup.new_tag("p")
                        error_tag.string = f"[Image could not be processed: {str(e)}]"
                        img.replace_with(error_tag)
            return soup

    def convert(
        self,
        file_stream: BinaryIO,
        stream_info: StreamInfo,
        **kwargs: Any,  # Options to pass to the converter
    ) -> DocumentConverterResult:
        # Parse the stream
        encoding = "utf-8" if stream_info.charset is None else stream_info.charset
        soup = BeautifulSoup(file_stream, "html.parser", from_encoding=encoding)

        soup = self.__replace_embedded_images_with_llm_desc(soup, **kwargs)
        # Remove javascript and style blocks
        for script in soup(["script", "style"]):
            script.extract()

        # Print only the main content
        body_elm = soup.find("body")
        webpage_text = ""
        if body_elm:
            webpage_text = _CustomMarkdownify(**kwargs).convert_soup(body_elm)
        else:
            webpage_text = _CustomMarkdownify(**kwargs).convert_soup(soup)

        assert isinstance(webpage_text, str)

        # remove leading and trailing \n
        webpage_text = webpage_text.strip()

        return DocumentConverterResult(
            markdown=webpage_text,
            title=None if soup.title is None else soup.title.string,
        )

    def convert_string(
        self, html_content: str, *, url: Optional[str] = None, **kwargs
    ) -> DocumentConverterResult:
        """
        Non-standard convenience method to convert a string to markdown.
        Given that many converters produce HTML as intermediate output, this
        allows for easy conversion of HTML to markdown.
        """
        return self.convert(
            file_stream=io.BytesIO(html_content.encode("utf-8")),
            stream_info=StreamInfo(
                mimetype="text/html",
                extension=".html",
                charset="utf-8",
                url=url,
            ),
            **kwargs,
        )
